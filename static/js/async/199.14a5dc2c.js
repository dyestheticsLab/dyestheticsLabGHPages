"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["199"],{343:function(e,t,n){n.r(t),n.d(t,{default:()=>o});var s=n(1549),a=n(6603);function i(e){let t=Object.assign({p:"p",strong:"strong",pre:"pre",code:"code"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:'Today I need to learn how to use Zustand. However, before I even started, I\ntold myself, "Wait a minute—let\'s complicate my life for a few minutes to see\nhow far I can get."'}),"\n",(0,s.jsxs)(t.p,{children:["First of all, you must already understand how ",(0,s.jsx)(t.strong,{children:"useSyncExternalStore"})," works\nbefore diving into what I'm doing."]}),"\n",(0,s.jsxs)(t.p,{children:["So what I'm going to do is create an observer creator, because—as you\nknow—",(0,s.jsx)(t.strong,{children:"useSyncExternalStore"})," requires two things: a function that subscribes\nit to an external store and a snapshot function. The subscription function is\nmeant to tell the observer to save a function to be executed later, which then\ncalls the snapshot function. When the snapshot function runs, it compares the\nprevious value with the new snapshot result to decide whether or not to\ntrigger a re-render."]}),"\n",(0,s.jsx)(t.p,{children:"Here's what the code might look like:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"const createObserver = <T>({ initialState }: { initialState: T }) => {\n  let state = initialState;\n  const listeners = new Set<() => void>();\n\n  const dispatch = () => {\n    listeners.forEach((listener) => listener());\n  };\n\n  return {\n    getState: (pickerFn?: (state: T) => any) =>\n      pickerFn ? pickerFn(state) : state,\n    setState: (newStateOrSetter: T | ((prevState: T) => T)) => {\n      if (typeof newStateOrSetter === 'function')\n        state = newStateOrSetter(state);\n      else state = newStateOrSetter;\n\n      dispatch();\n    },\n    subscribe: (listener: () => void) => {\n      listeners.add(listener);\n      return () => {\n        listeners.delete(listener);\n      };\n    },\n  };\n};\n"})}),"\n",(0,s.jsx)(t.p,{children:"The state is kept inside the closure, and the getState function accepts a\npicker function so that if you pass a big object, you aren't forcing all\nsubscribers to re-render every time—it's better to pick only the part of the\nobject you need to compare."}),"\n",(0,s.jsx)(t.p,{children:"Nice and done. Now, the problem with this approach is that if you create this\nat the top level, you're creating a singleton—even if you need it for just one\npage (I'm talking about CSR). So how do you scope it to a single page and then\nlet it disappear?"}),"\n",(0,s.jsx)(t.p,{children:"Well, we can use React Context. But before doing that, I'll create two hooks\nto simplify usage. They look anemic (a tech term, like in anemic classes)\nactually, but here they are anyway:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"const useCallbackSubscribe = (ObservableContext, pickerFn) => {\n  const { getState, subscribe } = useContext(ObservableContext);\n  const cb = useCallback(() => getState(pickerFn), [pickerFn, getState]);\n  return useSyncExternalStore(subscribe, cb);\n};\n\n// An optional, not optimized version just in case:\nconst useSubscribe = (ObservableContext, pickerFn) => {\n  const { getState, subscribe } = useContext(ObservableContext);\n  return useSyncExternalStore(subscribe, () => getState(pickerFn));\n};\n\nconst useNotify = (ObservableContext) => {\n  const { setState } = useContext(ObservableContext);\n  return setState;\n};\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now what follows is the creation of the context. Isn't that a singleton as\nwell? Yes—maybe this will prove useful later when I want to ensure that this\nis client-side only or for similar scenarios. Let's continue:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"export const IsActiveListenerContext = createContext<\n  ReturnType<typeof createObserver>\n>();\n\nexport const IsActiveListenerProvider = <T>({\n  initialValue,\n  children,\n}: {\n  initialValue: T;\n  children: ReactNode;\n}) => {\n  const [observer] = useState(() =>\n    createObserver<T>({ initialState: initialValue })\n  );\n\n  return (\n    <IsActiveListenerContext.Provider value={observer}>\n      {children}\n    </IsActiveListenerContext.Provider>\n  );\n};\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now we can have:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function Page() {\n  return (\n    <IsActiveListenerProvider initialValue={false}>\n      <Emisor />\n      {/* more code */}\n      <Listener />\n    </IsActiveListenerProvider>\n  );\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"For the Emisor component:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function Emisor() {\n  const notify = useNotify(IsActiveListenerContext);\n  const handleClick = () => {\n    notify((prev) => !prev);\n  };\n  return <button onClick={handleClick}>Click Me to Toggle</button>;\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"And for the Listener component:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function Listener() {\n  const isActive = useSubscribe(IsActiveListenerContext, (state) => state);\n  return <div>{isActive && 'Hello, I am active'}</div>;\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now it will work. Some additional considerations: I may need a smarter way to\ncreate contexts—a context factory that creates contexts when needed so I can\nchoose my listeners by key from a map. And why would I do that? Because\nmicrofrontends :v. I'm looking for a global way to communicate events\nthroughout my app, and yes, I need a more agnostic store. I think that\ncreateObserver is more than enough. You can subscribe to it with a useEffect\nor any other method you can imagine, and by using the picker, you can extract\nonly what you want from a big object (even though microfrontends say the API\nbetween your UI components should be minimal and clean)."}),"\n",(0,s.jsx)(t.p,{children:"I'm also looking for a way so that when subscribing, you can tell the\nobserver, \"Hey, when emitting, just do it for these listeners and not the\nothers.\" I'm thinking of something like this (heads up: a lot of any types , here, this was a last minute idea):"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"const createObserver = <T>({ initialState }: { initialState: T }) => {\n  let state = initialState;\n  const listeners = new Set<any>();\n\n  const resolveDispatch = ({\n    dispatch,\n    predicate,\n  }: {\n    dispatch: () => void;\n    predicate?: (state: T, meta?: any) => boolean;\n  }) => {\n    if (!predicate) return dispatch();\n    if (predicate(state)) dispatch();\n  };\n\n  const dispatch = (predicate?: (state: T, meta?: any) => boolean) => {\n    if (!predicate) {\n      listeners.forEach((listener) => resolveDispatch(listener));\n    } else {\n      listeners.forEach(\n        ({\n          dispatch,\n          meta,\n          predicate: innerPredicate,\n        }: {\n          dispatch: () => void;\n          meta?: any;\n          predicate?: (state: T, meta?: any) => boolean;\n        }) => {\n          if (predicate(state, meta)) {\n            resolveDispatch({ dispatch, predicate: innerPredicate });\n          }\n        }\n      );\n    }\n  };\n\n  return {\n    getState: (pickerFn?: (state: T) => any) =>\n      pickerFn ? pickerFn(state) : state,\n    setState: (\n      newStateOrSetter: T | ((prevState: T) => T),\n      predicate?: (state: T, meta?: any) => boolean\n    ) => {\n      if (typeof newStateOrSetter === 'function')\n        state = newStateOrSetter(state);\n      else state = newStateOrSetter;\n\n      dispatch(predicate);\n    },\n    subscribe: (listener: any) => {\n      listeners.add(listener);\n    },\n  };\n};\n"})}),"\n",(0,s.jsx)(t.p,{children:"And now it's time to check if this actually supports my idea for a\nmicrofrontend with an app shell."}),"\n",(0,s.jsx)(t.p,{children:"There is a caveat, though: now that I see this, subscribing to events in this\nway isn't fully possible. Maybe I need to create a factory here? See you in\nanother article where I continue to make my brain wrestle and my life harder."})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let o=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["blog%2Fcreating-a-complicated-observer.mdx"]={toc:[],title:"",headingTitle:"",frontmatter:{}}}}]);